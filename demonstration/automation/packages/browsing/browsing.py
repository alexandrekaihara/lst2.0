#
# Copyright (C) 2022 Alexandre Mitsuru Kaihara
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


from packages.system.echoX import echoC
from subprocess import Popen
from selenium import webdriver
from selenium.webdriver import FirefoxOptions
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.by import By
from configparser import ConfigParser
import platform
import sys
import time
import re
import os
import random
import linecache
import getpass
import signal

myName = "browsing"

driver = None
vdisplay = None

# Find the number of lines of the transferred file
def file_len(myfile):
	with open(myfile) as f:
		for i, l in enumerate(f):
			pass
	return i + 1

# Choose a URL from a private or business pool
def pick_url(porb_url, parser):
	nb = file_len(porb_url)
	rand = random.randint(1, nb)
	search = linecache.getline(porb_url, rand).replace ("\n", "")
	return search

# Open Firefox 
def create_driver():
	try:
		if platform.system() == "Linux":
			# Geckodriver is required because FirefoxDriver is deprecated
			opts = FirefoxOptions()
			opts.add_argument("--headless")
			driver = webdriver.Firefox(options=opts)
		elif platform.system() == "Windows":
			# On Windows, you can work without a Geckodriver because the Windows VMs have an old version of Firefox
			driver = webdriver.Firefox()			
		return driver
	except Exception as e:
		echoC(myName, "create_driver() error: " + str(e))
		return None

# Open URL 
def open_url(driver, url):
	try:
		# If a URL is not available, an exception is thrown after 60 seconds
		driver.set_page_load_timeout(60)
		driver.get(url)
	except Exception as e:
		echoC(myName, "open_url() error: " + str(e))
		return -1
	return 0

# Close Pop-Up
def close_popup(driver, var):
	try:
		driver.find_element(By.CSS_SELECTOR, var).click()
		time.sleep(5)
	except Exception as e:
		echoC(myName, "close_popup() error: " + str(e))
		return -1		
	return 0

# Search on website
def start_search(driver, keywords, var):
	try:
		# Determine the number of search terms and choose one randomly
		nb = file_len(keywords)
		rand = random.randint(1, nb)
		search = linecache.getline(keywords, rand)
		# Determine search field and enter search term
		elem = driver.find_element(By.NAME, var)
		elem.send_keys(search)
		elem.send_keys(Keys.RETURN)
		echoC(myName, "Searched: " + search)
		time.sleep(5)	
	except Exception as e:
		echoC(myName, "start_search() error: " + str(e))
		return -1
	return 0

# Click on a link based on the HTML tag name
def click_on_stuff(driver, tagname):
	# Determine all elements for the tag name
	links = driver.find_elements(By.TAG_NAME, tagname)
	# Check whether elements could be determined (empty list)
	if not links:
		echoC(myName, "click_on_stuff() error: No links found")
		return -1
	# Filtering all links that are not active (eg generated by JS)
	try:
		validLinks = [link for link in links if link.is_displayed()]	
	except Exception as e:
		echoC(myName, "click_on_stuff() error: is_displayed() exception: " + str(e))
		return -1
	# Otherwise randomly select an element
	try:
		l = validLinks[random.randint(0, len(validLinks)-1)]
	except Exception as e:
		echoC(myName, "click_on_stuff() error: random validLinks: " + str(e))
		return -1
	# If it is a non-visible element, another element is selected
	# If no visible element is found 5 times, the method is aborted (cause, eg, connection termination)
	cntFehler = 0
	while True:
		# Click on the determined element
		# Intercepting error messages for non-clickable elements
		time.sleep(5)
		try:
			l.click()
			echoC(myName, "Clicked on stuff")
			waitfor = random.randint(1, 40)
			time.sleep(waitfor)
			return 0
		except Exception as e:
			# 5 Trial tests are tolerated
			cntFehler = cntFehler + 1
			if cntFehler == 5:
				echoC(myName, "click_on_stuff() error: " + str(e))
				return -1
			# Determine a new link
			l = validLinks[random.randint(0, len(validLinks)-1)]

# Invoked when the browsing process is terminated by the mainscript (p.terminate ())
# Works only under Linux, because Windows does not work with signals
def exitAfterTimeout(signum, frame):
	echoC(myName, "Received signal '" + str(signum) + "', exiting")
	error = 0
	try:
		if driver != None:
			driver.quit()
			echoC(myName, "Quit driver successfully")
	except Exception as e:
		echoC(myName, "Error quitting driver")
		error = -1
	try:
		if vdisplay != None:
			vdisplay.stop()
			echoC(myName, "Stopped vdisplay successfully")
	except Exception as e:
		echoC(myName, "Error stopping vdisplay")
		error = -1
	sys.exit(error)

# The mode determines whether it should be surfed privately or business
def main(mode):
	
	# Forced termination of the browser by the Mainscript
	# Linux only 
	signal.signal(signal.SIGTERM, exitAfterTimeout)
	
	global myName
	myName = "browsing '" + mode + "'"
	
	# Linux: Start virtualized display
	if platform.system() == "Linux":
		from xvfbwrapper import Xvfb
		global vdisplay
		vdisplay = Xvfb()
		vdisplay.start()

	# Files for private or business browsing
	browse = 'packages/browsing/bbrowsing.txt'
	slist = 'packages/browsing/businessSearch.txt'
	if mode == 'p':
		browse = 'packages/browsing/pbrowsing.txt'
		slist = 'packages/browsing/privateSearch.txt'

	# Read private or business page from ini file
	parser = ConfigParser()
	parser.read('packages/browsing/browser.ini')
	site = pick_url(browse, parser)
	url = parser.get(site, 'url')

	echoC(myName, "Start browsing: " + url)

	# Open Firefox 
	global driver
	driver = create_driver()
	
	# Open URL (if Firefox is started)
	error = -1
	if driver != None:
		error = open_url(driver, url)

	if error == 0:
		# If a pop-up opens: Close pop-up
		if parser.getint(site, 'popup') == 1:		
			error = close_popup(driver, parser.get(site, 'button'))		

	if error == 0:
		# If a search is to be performed: Transfer the search terms and name of the search field to method start_search()
		if parser.getint(site, 'search') == 1:
			error = start_search(driver, slist, parser.get(site, 'search_query'))

	if error == 0:
		# If you want to click: Pass HTML tag to method click_on_stuff ()
		if parser.getint(site, 'click') == 1:
			# Always go back to the first website and click on the new link
			# Mode "e" is required by the attacker and is supposed to make sure that he is surfing his attacks in the Internet (e = endless)
			firstTime = True
			while random.randint(0, 4) != 0 or firstTime == True or mode == "e":
				firstTime = False
				
				error = click_on_stuff(driver, parser.get(site, 'tag_name'))
				# Refresh drivers
				try:
					driver.get(driver.current_url)
				except Exception as e:
					echoC(myName, "Error renewing driver after click_on_stuff()")
					continue

	if driver != None:
		# Close all browser windows 	
		driver.quit()

	# Linux: close virtualized Display 
	if platform.system() == "Linux":
		vdisplay.stop()

	echoC(myName, "Done")
	return error

if __name__ == "__main__":
    main(sys.argv[1])
